[gcode_macro START_PRINT]
gcode:
  status_homing
  G28
  #Get Bed and Extruder temperature from Slicer GCode
  {% set BED_TEMP = params.BED_TEMP|default(60)|float %}
  {% set EXTRUDER_TEMP = params.EXTRUDER_TEMP|default(200)|float %}
  SKEW_PROFILE LOAD=CaliFlower

  CLEAR_PAUSE
  G90

  status_heating
  G1 X145 Y150 Z150 F6000
  M117 Heatup Bed to {BED_TEMP}°C

  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={BED_TEMP}  
  TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={BED_TEMP*0.96} MAXIMUM={BED_TEMP*1.04}

  M117 Heat Nozzle to 150°C for TAP
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET=150
  TEMPERATURE_WAIT SENSOR=extruder MINIMUM={150*0.98} MAXIMUM={150*1.02}

  M117 Please clean nozzle. Waiting 1 min.
  G4 P60000
  G1 X145 Y150 Z10 F6000

  M117 Eddy-NG tap.
  status_calibrating_z
  PROBE_EDDY_NG_TAP

  M117 Adaptive Bedmeshing in progress.
  status_meshing
  BED_MESH_CALIBRATE method=rapid_scan HORIZONTAL_MOVE_Z=1.5
  #BED_MESH_CALIBRATE PROFILE=adaptive ADAPTIVE=1

  G1 Z10 F3000 ; move z up little to prevent scratching of surface
  G1 X2 Y2 Z10 F5000.0 ; move to start-line position

  M117 Heatup Nozzle to {EXTRUDER_TEMP}°C
  status_heating
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET={EXTRUDER_TEMP}
  TEMPERATURE_WAIT SENSOR=extruder MINIMUM={EXTRUDER_TEMP*0.98} MAXIMUM={EXTRUDER_TEMP*1.02}

  PRIME_LINE
  SFS_ENABLE
  status_printing
  M117

[gcode_macro END_PRINT]
gcode:

  M117 End print
  END_PRINT_UNLOAD
  TURN_OFF_HEATERS

  status_cooling
  
  M117 Present print
  PRESENT_PRINT

  M117
  M84 
  PROBE_EDDY_NG_SET_TAP_OFFSET VALUE=0
  SET_SKEW CLEAR=1
  SFS_DISABLE
  BED_MESH_CLEAR

[gcode_macro PRIME_LINE]
gcode: 
  SAVE_GCODE_STATE NAME=prime_line_state

  #Precondition extruder
  G92 E0 ; reset extruder
  G1 X2 Y20 Z1.0 F4000.0 ; move to start-line position
  G1 X2 Y20 Z0.3 F300.0 ; move z up little to prevent scratching of surface
  G1 X2 Y200.0 Z0.3 F1500.0 E15 ; draw 1st line
  G1 X2 Y200.0 Z0.4 F5000.0 ; move to side a little
  G1 X2 Y20 Z0.4 F1500.0 E30 ; draw 2nd line
  G92 E0 ; reset extruder
  G1 Z1.0 F300 ; move z up little to prevent scratching of surface

  RESTORE_GCODE_STATE NAME=prime_line_state

[gcode_macro PRESENT_PRINT]
gcode:
  SAVE_GCODE_STATE NAME=present_print_state

  {% set X_MAX = printer.toolhead.axis_maximum.x|float %}
  {% set Y_MAX = printer.toolhead.axis_maximum.y|float %}
  {% set Z_MAX = printer.toolhead.axis_maximum.z|float %}
  {% set Z_PARK_MIN = 200 | float %}
  {% set Z_PARK_LIFT = 10 | float %}

  # Move nozzle away from print while retracting
  G91
  G1 E-3 F300

  G90
  {% if printer.toolhead.position.z + Z_PARK_LIFT > Z_PARK_MIN %}
    G1 X{X_MAX / 2} Y{Y_MAX * 0.8} Z{printer.toolhead.position.z + Z_PARK_LIFT} F4000
  {% else %}
    G1 X{X_MAX / 2} Y{Y_MAX * 0.8} Z{Z_PARK_MIN} F4000
  {% endif %}

  RESTORE_GCODE_STATE NAME=present_print_state

[gcode_macro SET_ACTIVE_SPOOL]
gcode:
  {% if params.ID %}
    {% set id = params.ID|int %}
    {action_call_remote_method(
       "spoolman_set_active_spool",
       spool_id=id
    )}
  {% else %}
    {action_respond_info("Parameter 'ID' is required")}
  {% endif %}

[gcode_macro CLEAR_ACTIVE_SPOOL]
gcode:
  {action_call_remote_method(
    "spoolman_set_active_spool",
    spool_id=None
  )}

[gcode_macro TEST_SPEED]
# Home, get position, throw around toolhead, home again.
# If MCU stepper positions (first line in GET_POSITION) are greater than a full step different (your number of microsteps), then skipping occured.
# We only measure to a full step to accomodate for endstop variance.
# Example: TEST_SPEED SPEED=300 ACCEL=5000 ITERATIONS=10

description: Test for max speed and acceleration parameters for the printer. Procedure: Home -> ReadPositionFromMCU -> MovesToolhead@Vel&Accel -> Home -> ReadPositionfromMCU

gcode:
    # Speed
    {% set speed  = params.SPEED|default(printer.configfile.settings.printer.max_velocity)|int %}
    # Iterations
    {% set iterations = params.ITERATIONS|default(5)|int %}
    # Acceleration
    {% set accel  = params.ACCEL|default(printer.configfile.settings.printer.max_accel)|int %}
    # Minimum Cruise Ratio
    {% set min_cruise_ratio = params.MIN_CRUISE_RATIO|default(0.5)|float %}
    # Bounding inset for large pattern (helps prevent slamming the toolhead into the sides after small skips, and helps to account for machines with imperfectly set dimensions)
    {% set bound = params.BOUND|default(20)|int %}
    # Size for small pattern box
    {% set smallpatternsize = SMALLPATTERNSIZE|default(20)|int %}
    
    # Large pattern
        # Max positions, inset by BOUND
        {% set x_min = printer.toolhead.axis_minimum.x + bound %}
        {% set x_max = printer.toolhead.axis_maximum.x - bound %}
        {% set y_min = printer.toolhead.axis_minimum.y + bound %}
        {% set y_max = printer.toolhead.axis_maximum.y - bound %}
    
    # Small pattern at center
        # Find X/Y center point
        {% set x_center = (printer.toolhead.axis_minimum.x|float + printer.toolhead.axis_maximum.x|float ) / 2 %}
        {% set y_center = (printer.toolhead.axis_minimum.y|float + printer.toolhead.axis_maximum.y|float ) / 2 %}
        
        # Set small pattern box around center point
        {% set x_center_min = x_center - (smallpatternsize/2) %}
        {% set x_center_max = x_center + (smallpatternsize/2) %}
        {% set y_center_min = y_center - (smallpatternsize/2) %}
        {% set y_center_max = y_center + (smallpatternsize/2) %}

    # Save current gcode state (absolute/relative, etc)
    SAVE_GCODE_STATE NAME=TEST_SPEED
    
    # Output parameters to g-code terminal
    { action_respond_info("TEST_SPEED: starting %d iterations at speed %d, accel %d" % (iterations, speed, accel)) }
    
    # Home and get position for comparison later:
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28
        # QGL if not already QGLd (only if QGL section exists in config)
        {% if printer.configfile.settings.quad_gantry_level %}
            {% if printer.quad_gantry_level.applied == False %}
                QUAD_GANTRY_LEVEL
                G28 Z
            {% endif %}
        {% endif %} 
        # Move 50mm away from max position and home again (to help with hall effect endstop accuracy - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/24)
        G90
        G1 X{printer.toolhead.axis_maximum.x-50} Y{printer.toolhead.axis_maximum.y-50} F{30*60}
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28 X Y
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Go to starting position
    G0 X{x_min} Y{y_min} Z{bound + 10} F{speed*60}

    # Set new limits
    {% if printer.configfile.settings.printer.minimum_cruise_ratio is defined %}
        SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} MINIMUM_CRUISE_RATIO={min_cruise_ratio}
    {% else %}
        SET_VELOCITY_LIMIT VELOCITY={speed} ACCEL={accel} ACCEL_TO_DECEL={accel / 2}
    {% endif %}

    {% for i in range(iterations) %}
        # Large pattern diagonals
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_max} Y{y_max} F{speed*60}
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
        G0 X{x_min} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
        
        # Large pattern box
        G0 X{x_min} Y{y_min} F{speed*60}
        G0 X{x_min} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_max} F{speed*60}
        G0 X{x_max} Y{y_min} F{speed*60}
    
        # Small pattern diagonals
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_max} Y{y_center_max} F{speed*60}
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
        G0 X{x_center_min} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
        
        # Small pattern box
        G0 X{x_center_min} Y{y_center_min} F{speed*60}
        G0 X{x_center_min} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_max} F{speed*60}
        G0 X{x_center_max} Y{y_center_min} F{speed*60}
    {% endfor %}

    # Restore max speed/accel/accel_to_decel to their configured values
    {% if printer.configfile.settings.printer.minimum_cruise_ratio is defined %}
        SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} MINIMUM_CRUISE_RATIO={printer.configfile.settings.printer.minimum_cruise_ratio} 
    {% else %}
        SET_VELOCITY_LIMIT VELOCITY={printer.configfile.settings.printer.max_velocity} ACCEL={printer.configfile.settings.printer.max_accel} ACCEL_TO_DECEL={printer.configfile.settings.printer.max_accel_to_decel}
    {% endif %}

    # Re-home and get position again for comparison:
        M400 # Finish moves - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/66
        G28 # This is a full G28 to fix an issue with CoreXZ - https://github.com/AndrewEllis93/Print-Tuning-Guide/issues/12
        # Go to XY home positions (in case your homing override leaves it elsewhere)
        G90
        G0 X{printer.toolhead.axis_maximum.x-1} Y{printer.toolhead.axis_maximum.y-1} F{30*60}
        G4 P1000 
        GET_POSITION

    # Restore previous gcode state (absolute/relative, etc)
    RESTORE_GCODE_STATE NAME=TEST_SPEED

[gcode_macro nevermore_off]
gcode:
    SET_PIN PIN=nevermore VALUE=0
 
[gcode_macro nevermore_on]
gcode:
    SET_PIN PIN=nevermore VALUE=1
 
[gcode_macro nevermore_toggle]
gcode:
    {% if printer["output_pin nevermore"].value == 0 %}
        nevermore_off
    {% else %}
        nevermore_on
    {% endif %}

# https://klipper.discourse.group/t/interruptible-heat-soak/1552
[gcode_macro HEAT_SOAK]
description: heats the bed for a while
 
variable_target_temp: 0
variable_stage: None ## heating -> soaking -> done -> None
 
## in seconds
variable_check_interval: 10
variable_soak_time_remaining: 0
variable_total_time_elapsed: 0
 
gcode:
    {% set TARGET = params.TARGET | default(0) | float %}
    {% set DURATION = (params.DURATION | default(5) | int) * 60 %} ## minutes to seconds
 
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=target_temp         VALUE={ TARGET }
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage               VALUE="'heating'"
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE={ DURATION }
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed  VALUE=0
 
    ;; fire up the heater
    SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET={ TARGET }
 
    ;; run the fan to circulate air
    NEVERMORE_ON
 
    M84 ;; turn off steppers
 
    UPDATE_DELAYED_GCODE ID=heat_soaker DURATION={ check_interval }
 
[gcode_macro CANCEL_HEAT_SOAK]
description: cancels an in-progress HEAT_SOAK cycle
gcode:
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage VALUE="'cancel'"
    UPDATE_DELAYED_GCODE ID=heat_soaker DURATION=1
 
[delayed_gcode heat_soaker]
; ## debug
; { action_respond_info( printer['gcode_macro HEAT_SOAK'] | tojson )}
gcode:
    {% set heat_soak = printer['gcode_macro HEAT_SOAK'] %}
 
    ## update total time elapsed
    {% set total_time_elapsed = heat_soak.total_time_elapsed + heat_soak.check_interval %}
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed VALUE={ total_time_elapsed }
 
    {% set stage = heat_soak.stage %}
    {% if stage == "heating" and printer.heater_bed.temperature >= heat_soak.target_temp %}
        {% set stage = "soaking" %}
    {% endif %}
 
    {% if stage == "soaking" %}
        ## update soak countdown
        {% set soak_time_remaining = [heat_soak.soak_time_remaining - heat_soak.check_interval, 0] | max %}
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE={ soak_time_remaining }
 
        {% if soak_time_remaining == 0 %}
            {% set stage = "done" %}
        {% endif %}
    {% endif %}
 
    SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=stage VALUE="'{ stage }'"
 
    {% if stage in ("done", "cancel") %}
 
        {% if stage == "cancel" %}
            {% set stage = "done" %}
            TURN_OFF_HEATERS
            M107 ; turn off fan
 
            M117 { "soak cancelled after ~%.1fm" | format(total_time_elapsed / 60.0) }
        {% else %}
            M117 { "soak complete after %.1fm" | format(total_time_elapsed / 60.0) }
        {% endif %}
 
        ## reset all state vars, except stage, which may be queried via the api
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=target_temp         VALUE=0
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=soak_time_remaining VALUE=0
        SET_GCODE_VARIABLE MACRO=HEAT_SOAK VARIABLE=total_time_elapsed  VALUE=0
 
    {% else %}
 
        {% if total_time_elapsed % 90 == 0 %}
            ## output status periodically
            {% if stage == "heating" %}
                M117 { "heating -- %.1fm elapsed" | format(total_time_elapsed / 60.0) }
            {% elif stage == "soaking" %}
                M117 { "soaking -- %.1fm remaining" | format(soak_time_remaining / 60.0) }
            {% endif %}
        {% endif %}
 
        ## trigger ourselves again
        UPDATE_DELAYED_GCODE ID=heat_soaker DURATION={ heat_soak.check_interval }
 
        ## dwell for 1ms to prevent from going idle
        G4 P1
 
    {% endif %}

[gcode_macro TAP_MESH]
gcode:
  G28
  
  CLEAR_PAUSE
  G90
  
  status_heating
  
  G1 X145 Y150 Z150 F6000
  M117 Heatup Bed to 50°C

  SET_HEATER_TEMPERATURE HEATER=heater_bed TARGET=50
  TEMPERATURE_WAIT SENSOR=heater_bed MINIMUM={50*0.96} MAXIMUM={50*1.04}

  M117 Heat Nozzle to 150°C for TAP
  SET_HEATER_TEMPERATURE HEATER=extruder TARGET=150
  TEMPERATURE_WAIT SENSOR=extruder MINIMUM={150*0.98} MAXIMUM={150*1.02}

  M117 Please clean nozzle. Waiting 1 min.
  G4 P60000
  G1 X145 Y150 Z10 F6000

  M117 Eddy-NG tap.
  status_calibrating_z
  PROBE_EDDY_NG_TAP

  M117 Bedmeshing in progress.
  BED_MESH_CALIBRATE METHOD=rapid_scan

[gcode_macro LOAD_FILAMENT]
variable_load_distance:  50
variable_purge_distance:  25
gcode:
    {% set speed = params.SPEED|default(300) %}
    {% set max_velocity = printer.configfile.settings['extruder'].max_extrude_only_velocity  * 60 %}
    SAVE_GCODE_STATE NAME=load_state
    G91
    G92 E0
    G1 E{load_distance} F{max_velocity} # fast-load
    G1 E{purge_distance} F{speed} # purge
    RESTORE_GCODE_STATE NAME=load_state

[gcode_macro UNLOAD_FILAMENT]
variable_unload_distance:  50
variable_purge_distance:  5
gcode:
    {% set speed = params.SPEED|default(100) %}
    {% set max_velocity = printer.configfile.settings['extruder'].max_extrude_only_velocity  * 60 %}
    SAVE_GCODE_STATE NAME=unload_state
    G91
    G92 E0
    G1 E{purge_distance} F{speed} # purge
    G1 E-{unload_distance} F{max_velocity} # fast-unload
    RESTORE_GCODE_STATE NAME=unload_state

[gcode_macro END_PRINT_UNLOAD]
description: Unloads after a print is finished.
gcode:
    G91
    G92 E0
    G1 E-50 F100 #fast-unload

[gcode_macro _CLIENT_VARIABLE]
variable_use_custom_pos   : True ; use custom park coordinates for x,y [True/False]
variable_custom_park_x    : 0   ; custom x position; value must be within your defined min and max of X
variable_custom_park_y    : 150   ; custom y position; value must be within your defined min and max of Y
#variable_custom_park_dz   : 2.0   ; custom dz value; the value in mm to lift the nozzle when move to park position
variable_retract          : 5   ; the value to retract while PAUSE
variable_cancel_retract   : 5.0   ; the value to retract while CANCEL_PRINT
variable_speed_retract    : 35.0  ; retract speed in mm/s
variable_unretract        : 5   ; the value to unretract while RESUME
variable_speed_unretract  : 35.0  ; unretract speed in mm/s
#variable_speed_hop        : 15.0  ; z move speed in mm/s
#variable_speed_move       : 100.0 ; move speed in mm/s
variable_park_at_cancel   : True ; allow to move the toolhead to park while execute CANCEL_PRINT [True/False]
variable_park_at_cancel_x : 0  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
variable_park_at_cancel_y : 280  ; different park position during CANCEL_PRINT [None/Position as Float]; park_at_cancel must be True
## !!! Caution [firmware_retraction] must be defined in the printer.cfg if you set use_fw_retract: True !!!
#variable_use_fw_retract   : False ; use fw_retraction instead of the manual version [True/False]
#variable_idle_timeout     : 0     ; time in sec until idle_timeout kicks in. Value 0 means that no value will be set or restored
variable_runout_sensor    : "filament_switch_sensor runout"    ; If a sensor is defined, it will be used to cancel the execution of RESUME in case no filament is detected.
##                                   Specify the config name of the runout sensor e.g "filament_switch_sensor runout". Hint use the same as in your printer.cfg
## !!! Custom macros, please use with care and review the section of the corresponding macro.
## These macros are for simple operations like setting a status LED. Please make sure your macro does not interfere with the basic macro functions.
## Only  single line commands are supported, please create a macro if you need more than one command.
#variable_user_pause_macro : ""    ; Everything inside the "" will be executed after the klipper base pause (PAUSE_BASE) function
#variable_user_resume_macro: ""    ; Everything inside the "" will be executed before the klipper base resume (RESUME_BASE) function
variable_user_cancel_macro: "SFS_DISABLE"    ; Everything inside the "" will be executed before the klipper base cancel (CANCEL_PRINT_BASE) function
gcode: